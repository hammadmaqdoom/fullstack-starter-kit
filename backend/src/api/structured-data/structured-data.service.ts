import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { JsonLdSchemaEntity, SchemaType } from './entities/json-ld-schema.entity';
import { StructuredDataTemplateEntity } from './entities/structured-data-template.entity';
import { ContentEntity } from '@/api/content/entities/content.entity';

@Injectable()
export class StructuredDataService {
  constructor(
    @InjectRepository(JsonLdSchemaEntity)
    private readonly jsonLdSchemaRepository: Repository<JsonLdSchemaEntity>,
    @InjectRepository(StructuredDataTemplateEntity)
    private readonly templateRepository: Repository<StructuredDataTemplateEntity>,
    @InjectRepository(ContentEntity)
    private readonly contentRepository: Repository<ContentEntity>,
  ) {}

  async generateForContent(contentId: string): Promise<any[]> {
    const content = await this.contentRepository.findOne({
      where: { id: contentId },
      relations: ['author', 'category', 'tags'],
    });

    if (!content) {
      throw new NotFoundException('Content not found');
    }

    const schemas: any[] = [];

    // Get global schemas
    const globalSchemas = await this.jsonLdSchemaRepository.find({
      where: { isGlobal: true },
    });

    schemas.push(...globalSchemas.map(s => s.schemaData));

    // Get content-specific schemas
    const contentSchemas = await this.jsonLdSchemaRepository.find({
      where: { contentId },
    });

    schemas.push(...contentSchemas.map(s => s.schemaData));

    // Auto-generate based on content type
    const autoGenerated = await this.autoGenerateSchemas(content);
    schemas.push(...autoGenerated);

    return schemas;
  }

  private async autoGenerateSchemas(content: ContentEntity): Promise<any[]> {
    const schemas: any[] = [];
    const baseUrl = process.env.FRONTEND_URL || 'http://localhost:3000';

    // Generate Article/BlogPosting schema
    if (content.type === 'blog' && content.status === 'published') {
      const articleSchema = {
        '@context': 'https://schema.org',
        '@type': 'BlogPosting',
        headline: content.title,
        description: content.excerpt || content.title,
        image: content.featuredImage,
        datePublished: content.publishedAt,
        dateModified: content.updatedAt,
        author: content.author ? {
          '@type': 'Person',
          name: content.author.username || content.author.email,
        } : undefined,
        publisher: {
          '@type': 'Organization',
          name: process.env.SITE_NAME || 'Site Name',
        },
        mainEntityOfPage: {
          '@type': 'WebPage',
          '@id': `${baseUrl}/blog/${content.slug}`,
        },
      };
      schemas.push(articleSchema);
    }

    // Generate WebPage schema
    const webpageSchema = {
      '@context': 'https://schema.org',
      '@type': 'WebPage',
      name: content.title,
      description: content.excerpt || content.title,
      url: `${baseUrl}/${content.type}/${content.slug}`,
    };
    schemas.push(webpageSchema);

    // Generate BreadcrumbList if category exists
    if (content.category) {
      const breadcrumbSchema = {
        '@context': 'https://schema.org',
        '@type': 'BreadcrumbList',
        itemListElement: [
          {
            '@type': 'ListItem',
            position: 1,
            name: 'Home',
            item: baseUrl,
          },
          {
            '@type': 'ListItem',
            position: 2,
            name: content.category.name,
            item: `${baseUrl}/blog/category/${content.category.slug}`,
          },
          {
            '@type': 'ListItem',
            position: 3,
            name: content.title,
            item: `${baseUrl}/blog/${content.slug}`,
          },
        ],
      };
      schemas.push(breadcrumbSchema);
    }

    return schemas;
  }

  async createSchema(schemaData: any, contentId?: string, isGlobal = false) {
    const schema = this.jsonLdSchemaRepository.create({
      schemaType: schemaData['@type'] as SchemaType,
      schemaData,
      contentId,
      isGlobal,
    });
    return this.jsonLdSchemaRepository.save(schema);
  }

  async findAllTemplates() {
    return this.templateRepository.find({
      where: { isActive: true },
    });
  }

  async createTemplate(template: Partial<StructuredDataTemplateEntity>) {
    const newTemplate = this.templateRepository.create(template);
    return this.templateRepository.save(newTemplate);
  }

  async updateTemplate(id: string, template: Partial<StructuredDataTemplateEntity>) {
    await this.templateRepository.update(id, template);
    return this.templateRepository.findOne({ where: { id } });
  }
}

